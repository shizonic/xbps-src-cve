#!/usr/bin/env bash
# cve-check <SRCPKGDIR> ... - Checks packages on xbps-src for CVEs
if [ ! $CVECACHE ]
then
	CVECACHE=${XDG_CACHE_HOME:-$HOME/.local/cache}/cve-check
	mkdir -p $CVECACHE
fi

pull_cves() {
	# Check for required packages
	if ! hash xsltproc >/dev/null 2>&1
	then
		echo "This script requires xsltproc to be available, install libxslt." >&2
		exit 1
	fi
	
	if [ ! $WGETCMD ]
	then
		WGETCMD="wget"
	fi
	if ! hash $WGETCMD >/dev/null 2>&1
	then
		echo "This script requires wget to be available, install wget." >&2
		exit 1
	fi

	# Download and process all nvdcve databases from 2002 to 2018 and modified'
	for db in {2002..2018} modified
	do
		if [  ! -f ${CVECACHE}/nvdcve-2.0-${db}.xml.gz ]
		then
			$WGETCMD -q --show-progress -O ${CVECACHE}/nvdcve-2.0-${db}.xml.gz https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-${db}.xml.gz
		fi

		# Convert each database into a csv file
		if [ ! -f ${CVECACHE}/nvdcve-2.0-${db}.csv ] || [ ! -s ${CVECACHE}/nvdcve-2.0-${db}.csv ]
		then
			printf "Converting nvdcve-2.0-%s.xml to CSV.\\n" "$db"
			zcat ${CVECACHE}/nvdcve-2.0-${db}.xml.gz | 
				xsltproc nvdcve2simple.xsl - | 
				# Remove all hardware
				grep -v ':cpe:/h:' |
				# Remove vulnerabilities that only apply to specific stuff we don't care about
				grep -Ev ':~~~windows~~|:~~~jenkins~~|:~~~wordpress~~|~~~chrome~~|~~~edge~~|~~~internet_explorer~~|~~~esr~~|~~~android~~|~~~mac|~~lts~~~' |
				# Remove unversioned vulnerabilities
				grep -v ':-$' |
				# Remove OSes as possible (Linux kernel is counted as an OS)
				grep -Ev ':cpe:/o:(canonical|supermicro|trivum|arcelikas|google|lica|oracle|qualcomm|debian|sap|intel|apple|redhat|freebsd|openbsd|ibm|microsoft|novell|netbsd|cisco|sun|fedoraproject|tendacn|ravpower|silextechnology|fastweb|netis-systems|dlink|d-link|hanwha-security|foxconn|iball|meross|conceptronic|citrix|foscam|vmware|trendnet|slackware|juniper|asus|ubuntu|watchguard|opensuse|linux:linux_kernel:2|linux:linux_kernel:3.[02-9]|linux:linux_kernel:3.1[0-5]|linux:linux_kernel:3.17|linux:linux_kernel:3.19|linux:linux_kernel:[1-2])' |
				# Remove software as possible
				grep -Ev ':cpe:/a:(apple:safari|apple:itunes|apple:quicktime|google:chrome|microsoft:|opera:opera_browser|symantec:antivirus|adobe:acrobat|ibm:lotus_domino|reahat:policycoreutils|wordpress:wordpress|cisco:|opensuse:open_build_service|gitlab:gitlab|openssl:openssl|ibm:|mozilla:firefox:[1-5]|mozilla:thunderbird:[1-5]|apple:apple_tv|apple:icloud|sap:|signal:signal|foxitsoftware:|juniper:|graylog:|cybozu:|haxx:libcurl)' > ${CVECACHE}/nvdcve-2.0-${db}.csv
		fi
	done
}

for arg; do
	shift
	[ "$arg" = "-p" ] || [ "$arg" = "--pull" ] && pull_cves && continue
	set -- "$@" "$arg"
done

# Check if we have our beloved database
for db in {2002..2018} modified
do
	if [ ! -f ${CVECACHE}/nvdcve-2.0-${db}.csv ]
	then
		echo "cve database wasn't made, run cve-check with -p, --pull option" >&2
		exit 1
	fi
done

# xdistdir is used to check 
if ! hash xdistdir
then
	echo "xdistdir is missing, install xtools" >&2
	exit 1
fi

if ! xbpsdir="$(xdistdir)"
then
	echo "Couldn't find xbps-src sourcedir" >&2
	exit 1
fi

while [ $# -gt 0 ]
do
	pkg=$1
	shift

	pkgdir="${xbpsdir}/srcpkgs/${pkg}"

	# If the package given was wrong, ignore it
	if [ ! -f ${pkgdir}/template ]
	then
		printf "no package %s.\\n" "$pkg"
		continue
	fi

	# Source the template so we get pkgname= and version=
	source ${pkgdir}/template >/dev/null 2>&1 || continue

	# check for srcpkgs/$pkgname/cve-check
	if [ -f ${pkgdir}/cve-check ]
	then
		printf "using srcpkgs/%s/cve-check.\\n" "$pkg"
		source ${pkgdir}/cve-check
	fi

	# all packages are in lower case in the database so just switch
	# it here as well.
	pkgname=${pkgname,,}

	# Take care of some packages automatically
	# maybe they should be in cve-check
	case $pkgname in
		mbedtls) pkgname=mbed_tls ;;
		tiff) pkgname=libtiff ;;
		python3 ) pkgname=python ;;
		python-* ) pkgname=${pkgname#*python-} ;;
		nodejs ) pkgname=node.js ;;
		ImageMagick6) pkgname=imagemagick ;;
		webkit2gtk) pkgname=webkitgtk%2b ;;
		apache-*) pkgname=${pkgname#*apache*-} ;;
		apache) pkgname=http_server ;;
		sleuthkit ) pkgname=the_sleuth_kit ;;
		linux[0-9]* ) pkgname=linux_kernel ;;
		gstreamer1 ) pkgname=gstreamer ;;
	esac

	entry="$(awk -F: -v pkg="$pkgname" -v version="$version" '( $6 == pkg && $7 == version ){ print $1":"$2 }' ${CVECACHE}/nvdcve-2.0*.csv)"

	if [ -z "$entry" ]
	then
		continue
	fi

	for entry in $entry
	do
		# We are given a string formatted as
		#
		# CVE:SEVERITY
		# use bash substitution to get all of them
		cve="${entry%%:*}" ; entry="${entry#*:}"
		sev="${entry%%:*}"

		# We check if it is a directory or a symlink because some packages links
		# to the patches directory of another one, likewise on the find we use -L
		# so we follow it if it's symlinked
		if [ -d ${pkgdir}/patches ] || [ -L ${pkgdir}/patches ]
		then
			files="$(find -L ${pkgdir}/patches -maxdepth 1 -mindepth 1 -type f)"

			# Check if we have a patch named after the cve in patches
			if [[ "$files" =~ ${cve#*CVE-} ]]
			then
				# the CVE is patched, huzzah!
				continue
			fi

			# Check if there is a patch with a string matching the CVE
			if grep -q $cve ${pkgdir}/patches/*
			then
				continue
			fi
		fi

		# Check the cve-check file for CVEs we can ignore, the reason
		# is up for the maintainer of the package, maybe we disable a
		# compile option that triggers the CVE
		if [ "$ignores" ]
		then
			# We are ignoring this specific CVE
			if [[ "$ignores" == *${cve#*-}* ]]
			then
				continue
			fi
		fi

		# If we reached here we are vulnerable
		cves="${cves} $cve:$sev"
	done

	if [ "$cves" ]
	then
		printf "%s (%s) %s:\\n" "$pkg" "$pkgname" "$version"
		for cve in $cves
		do
			cve="$(tr : ' ' <<< $cve)"
			printf " %s\\n"  "$cve"
		done
	fi
done
